# Binary Exploitation dan Konsep Buffer Overflow

## **Daftar Isi**

- [**Apa itu Binary Exploitation?**](#apa-itu-binary-exploitation?)
- [**Konsep Buffer Overflow**](#konsep-buffer-overflow)
- [**Praktik Buffer Overflow**](#konsep-forensik)

## Apa Itu Binary Exploitation? 
Binary exploitation adalah salah satu program CTF yang fokus untuk menemukan kerentanan dalam program dan mengeksploitasinya untuk mendapatkan kendali atas shell atau
memodifikasi fungsi program. Sedangkan untuk binary adalah kode mesin untuk dieksekusi oleh komputer. Dalam CTF, sebagian besar binary berupa file ELF Linux atau Windows
yang dapat dieksekusi.  
## Konsep Buffer Overflow
Sebelum memahami bagaimana buffer overflow dilakukan. Berikut adalah beberapa hal yang harus dipahami :  
### 1. Layout Memori
Layout memori adalah gambaran memori hasil dari sebuah program yang dieksekusi.  
![Untitled](https://user-images.githubusercontent.com/87466033/129343635-8ccb66e2-1007-4a83-b1b5-d4a17a3c15cf.png)  

**Keterangan**  
segmen .text  = berisi perintah perintah program seperti move, leave, push, dan lain-lain  
segmen .data  = berisi variable global dalam program  
segmen .bss   = berisi variable global yang tidak terinisialisasi  
heap          = menyimpan memori secara dinamis, contoh perintah yang akan disimpan di heap adalah malloc, new, dll  
stack         = menyimpan memori secara statis  
kernel        = program tidak dapat mengakses bagian ini  
  
**32 bit vs 64 bit**  
Layout memori secara garis besar dibagi menjadi 2, yaitu layout memori 32 bit (x86) dan 64 bit (x64). Selain berbeda jumlah bitnya, batas RAM pada 32 bit hanya 4GB (1GB untuk 
kernel, 3 GB untuk program) sedangkan RAM pada 64 bit bisa mencapai ratusan GB atau bahkan lebih. Kemudian untuk 32 bit memiliki jumlah 4 bytes  dan 64 bit memiliki jumlah 8 bytes 
dimana banyaknya bytes ini menunjukkan banyaknya kolom pada tiap address di layout memori. Untuk lebih jelasnya akan dipraktikan nanti :)  

### 2. ASLR
Pada layout memori diatas lokasi stack bisa ditentukan dengan mudah dengan perhitungan banyak address. Sedangkan stack sendiri adalah salah satu celah paling sering yang dilakukan 
peretas dalam melakukan exploitation. Untuk mencegah hal ini, maka digunakanlah metode ASLR (Addres Space Layout Randomization). Berikut adalah layout memori ketika menggunakan 
ASLR.  

![Untitled](https://user-images.githubusercontent.com/87466033/129348709-c35be273-96e8-4979-8c12-ee60cd7e8b71.png)  
  
Dengan menggunakan ASLR address stack dan heap tidak mudah untuk diketahui sehingga dapat menjadi cara untuk mempersulit peretas dalam mencari kelemahan sebuah program.  
  
### 3. Stack
Stack adalah salah satu struktur data yang sering digunakan dalam penyimpanan objek maupun variable. Fungsi bawaan stack ada 2 yaitu **push** untuk memasukkan data ke dalam stack 
dan **pop** untuk menghapus data dari stack. Secara garis besar layout dari stack adalah sebagai berikut :  
```
program
  main : 
    push <parameter n>
    push <parameter 2>
    push <parameter 1>
    call <jumlah>
```
![Untitled](https://user-images.githubusercontent.com/87466033/129351559-65b6050b-6927-474c-b4a9-3cd6bd51fc0c.png)  
  
**Keterangan**
warna biru  = terjadi di fungsi main  
warna grey  = terjadi di fungsi jumlah  
  
Di dalam stack terdapat istilah EBP (Extended Base Pointer) dan ESP (Extended Stack Pointer) dimana EBP adalah batas bawah dari stack dan ESP adalah batas atas dari stack. Pada 
gambar diatas, EBP dan ESP terdapat di fungsi jumlah setelah fungsi main memanggil fungsi jumlah. Apabila fungsi jumlah sudah menyelesaikan tugasnya, maka EBP dan ESP kembali ke 
fungsi main. Berbeda dengan heap, pemanggilan urutan fungsi dari alamat tinggi ke alamat rendah.  
  
## Praktik Buffer Overflow
install gdb  
```
git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit
```
compile file
```
gcc -no-pie -fno-pic -fno-stack-protector -fno-builtin -mpreferred-stack-boundary=2 -m32 nama_file.c -o nama_output
gdb gdb -q nama_output
```
beberapa command yang sering digunakan di gdb
```
pdisas nama_fungsi
break *nama_fungsi
r
ni
continue
```
